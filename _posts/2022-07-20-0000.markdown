---
layout: post
title:  "A software engineering medley"
date:   2022-06-01T00:00:00+00:00
tags: [sweng]
published: false
---

I wrote on software engineering papers and articles. They are lighter reading than technical papers but are interesting. I chose them by my interest rather than a criteria. I included some papers from nearby fields where it seemed appropriate.

## How Work From Home Affects Collaboration (in the pandemic)

Working from home reduces the number of meeting hours and increases the amount of time spent sending messages. The number of focused hours is overall greater than when working in an office. Behavior changed less for those who worked from home before the pandemic than for those who shifted to working from home.

## Large Scale Analysis of Multitasking Behavior During Remote Meetings

Longer meetings and meetings with more people have more multitasking. Morning meetings have more multitasking than afternoon meetings. Prior work shows that people are more focused in the afternoon. Scheduled meetings have more multitasking than ad hoc meetings. More multitasking occurs Monday-Thursday than on Friday.

## “A Pace Not Dictated by Electrons”: An Empirical Study of Work Without Email

When study participants did not use email at work they spent more time, on average, on a given window without switching windows. They reported feeling more focused, and enjoying their work more. The participants were less stressed, as measured by heart rate variability.

## Physiological Effects of Crunch

TODO:

## Towards a Theory of Software Developer Job Satisfaction and Perceived Productivity

Developers chose perceived productivity, explicit rewards, and their manager as more important factors for satisfaction, compared to other factors including autonomy, being free of interruptions and availability of documentation. Additionally, developers chose poor architecture and legacy code as being the most impactful challenges they face, compared to other challenges like poorly defined goals or lack of vision. These findings may be a reflection of most software work taking place on large existing code bases rather than greenfield code.

The most satisfied developers are the ones who feel their work is impactful and that they are an important contributor. Those who enjoyed autonomy and were able to complete tasks felt most productive.

## Why software projects need heroes

TODO:

## A Rational Design Process - How and Why to Fake It

There will never be a perfect software development process. Many factors are to blame. For example, the people who want the software to be built often do not fully understand what they want. Developers may have additional motives, like a fascination with a particular technology.

The authors argue that despite the impossibility of a perfect process, we should still strive for it. The 'perfect' process documented appears waterfall-like, with stringent and complete requirements and module architecture being mapped out before any implementation.

The discussion on documentation is more entertaining. Documentation is poorly organized and it consists of boring verbose prose and inconsistent and vague terms. It's usually written towards the end of the project when the authors take major ideas for granted, and are only interested in writing the small details. It can be improved by using strictly typed shorthands, and including each fact exactly once. Each section should answer a defined question.

## <https://blog.pragmaticengineer.com/project-management-at-big-tech/>

TODO:

## Here we go again: why is it difficult for developers to learn another programming language?

Experienced programmers learn new languages by reading and consuming material by themselves. They first learn what they need and don't worry about advanced features. Learning is hard for everyone, because trying to relate new knowledge to existing knowledge can lead to interference; false assumptions are made about the new domain.

Language designers and teachers should try to link concepts in instructional material to existing languages. It is a good idea to explicitly mention the reasons behind language design choices.

## Empirical analysis of Programming Language Adoption

Programmers tend to choose the language for a project based on the languages they have already used, or language popularity. There is a tendency for programmers to stay in language families, reuse languages they have used before, or choose popular languages.

When choosing a new language, open source library ecosystems and the ease of extending existing code are the most important factors. Other important factors include team and personal familiarity, performance and portability. Simplicity and commercial libraries are the least important factors.

## Neurological divide: an fMRI study of prose and code writing

Writing code activates the top-down planning areas of the brain more than writing prose does. Writing prose was found to activate the left side of the brain more than the right side, while writing code did the opposite. The left side activation is associated with language while the right side is associated with attention, memory and spatial reasoning. The paper concludes that the two tasks are very different from the brain's perspective.

## Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code

It is common for software requirements to be unspecified. This makes it difficult to determine what the code is supposed to do, and therefore difficult to determine what is a bug. The authors detected bugs by inferring correct behaviors. For example, in the case that 1000 calls to a lock function are followed by an unlock function, but 1 call is not, you could infer that the case without the call to unlock is a bug. Another example is when a contradiction implies the presence of a bug. For example, the code

```cpp
if (foo != null){
    foo->bar()
}
```

demonstrates a contradictory belief, and therefore a bug.

The authors present a tool which detects these instances via pattern matching and stats. They found around 200 bugs in the Linux kernel and OpenBSD, mostly related to null pointers.

## Static vs dynamic typed languages: an intentionally rigged experiment

TODO:

## The Paradox of the Assisted User: Guidance can be Counterproductive

User interfaces can harm user experience and user cognitive performance. The authors grouped interfaces into external and internal classes. External interfaces show domain constraints visually, while internal interfaces do not. For example, an external interface might grey out impossible actions.

The authors found that users performed better on a Tower of Hanoi game with an internal interface as opposed to an external one. Those users retained more information about the task after an 8 month wait. Additionally, users given a graphical timetabling puzzle performed no worse with an internal interface than an external one. The users with the external interface performed fewer superfluous actions. This indicates they thought more about each action.

## Electronic Publication and the Narrowing of Science and Scholarship

As scientific works have become easier to find online compared to in the past, citations have become more concentrated among fewer papers, and those papers are more recent.

## A Time Leap Challenge for SAT Solving (2020)

The relative impact of algorithm improvements and hardware improvements on SAT benchmarks since in the years 2000-2020 have been roughly equal. That is: both algorithm and hardware improvements significantly improve the overall effectiveness of SAT techniques, and in roughly equal measure.

## Links

- [Vivek Haldar's Youtube channel](https://www.youtube.com/c/VivekHaldar/videos)
- [Ian Schreiber's talk on the Physiological Effects of Crunch](https://www.youtube.com/watch?v=Sb2U_9IGgc0)
