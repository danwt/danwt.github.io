---
layout: post
title:  "Lower bound (time) on approximate agreement in shared memory"
date:   2021-12-03T00:00:00+00:00
tags: [shared_memory]
published: true
---

## Algorithm

Consider an asynchronous shared memory model with single write registers and no process failures. Approximate agreement between n processes is the problem of agreeing n output values within ε of each other, and all falling in the interval [min(input values), max(input values)], where the input values are assigned 1-1 to processes.

## Result and proof

Any solution with input values in {0, 1} and ε < 1 that provides obstruction freedom (each process will finish if it is scheduled for sufficiently many consecutive steps) has time complexity at least n.

Proof: suppose for contradiction suppose it's possible in less than n steps. Take two solo executions σi and σj of Pi and Pj, starting at states Ci and Cj. In Ci all input values are 0, and in Cj all input values are 1. Pi and Pj will output 0 and 1. Both Pi and Pj cannot distinguish Ci and Cj from a starting point C, where Pi is given input 0 and Pj is given 1.

![]({{ site.url }}/assets/2021-12-03/diagram.png){: width="90%" .centered }

Moreover, in any execution a process does not have time to read the register of all other processes and write to its own register. This at least one of Pi and Pj will not have time to distinguish Ci (Cj) from C. To see this, without loss of generality, if Pi does not read from Pj during σi then the execution σjσi, starting from C, will not be valid. If Pi does read from Pj, but does not write to its own register, then Pj cannot distinguish C and the state after running σi from C. Therefore, starting from C, σiσj will not be valid □

## Links

- [Hagit Attiya; Faith Ellen, Impossibility Results for Distributed Computing , Morgan & Claypool, 2014.](https://ieeexplore.ieee.org/document/6855592/)
