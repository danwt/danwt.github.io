---
layout: post
title:  "Amazon Builder's Library. TLDR;"
date:   2022-03-05 19:12:00 +0000
categories: sweng
published: false
---

AWS publishes a collection of PDFs containing tips and tricks for building scalable systems. I tried to trim the fat and present valuable points from each article in two paragraphs. I downloaded the PDFs on March 5th 2022 so any articles posted after that date aren't included.

## Using load shedding to avoid overload - David Yanacek

Tips for not killing your services by overloading them:

Shed requests which would cause load to get too high and lead to a cascading performance degradation. Don't forget to filter out the latency measurements for rejected requests from your latency measurements of client rpc calls. Also, make sure that the shedding threshold is not set lower than the reactive scaling threshold. If you don't, the reactive scaling will not trigger.

Drop doomed requests by making clients include a timeout hint and when the timeout is reached server-side, kill the request. Make the timeout hint transitive by subtracting the time taken by each service before passing the request downstream. Be aware of clock sync issues there. Similarly, check a request to see if it has been sitting in a queue for a long time, before starting to work on it. Throw it out if it's too old, in order to get to the fresher requests sooner.

Pagination helps to avoid wasted work and makes it easier to estimate the time to respond to a request. Return an iterator or similar instead of a large result. When API's are multi-step and include, for example, `start` and `end` calls, prioritize `end` calls to make sure that clients who began their request are able to finish them.

## Workload isolation using shuffle-sharding - Colm MacCárthaigh

Shuffle sharding is a technique to improve the reliability of a fleet of clients who may share common resources or logical dependencies. For example, if you have a number of clients who need work done, and a number of workers, you would like to match clients to workers in a many-to-many fashion such that the failure of an individual worker effects as few clients as possible. Concretely, if you have _n_ clients and _m_ workers and each client requires _k_ workers with _k_ < _m_ then you should should try to make sure that the size of the overlap between the sets of _k_ workers assigned to any two clients is minimized.

![]({{ site.url }}/assets/2022-05-03-1/shuffle_sharding.png)

The image shows a configuration where each client is assigned two workers. Even if the two workers of a single client fail, the other clients will both still have a single functioning worker.

The technique is especially useful if resource failure is correlated to the client. For instance, if the client is a server who comes under DDOS attack then all their workers may fail fast.

## Timeouts, retries, and backoff with jitter - Marc Brooker

Use capped exponential backoff to avoid overloading a system with retires. You can combine this with a token bucket algorithm for requests. Also, add jitter to any timers in the system, but make it deterministic, not random, in order to not end up in debugging hell.

## Static stability using Availability Zones - Becky Weiss, Mike Furr

Define static stability as being stable in the face of failure, without needing to reactively provision more resources. In practice this means having additional resources on standby such that when a failure occurs, the service can use the reserve resources while the failed resources are replaced.

## Reliability, constant work, and a good cup of coffee - Colm MacCárthaigh

Improve stability by always doing the same (maximum) amount of work instead of varying and scaling up the amount of work. If there isn't much work to be done then create dummy work. The reduced workload variance is more predictable and there will be fewer ways for your system to fail in a cascade. A good example is to have a downstream service read configurations from an upstream service in a loop instead of having the upstream service push a new configuration on changes. The solution requires less logic and savings in dev and maintenance cost cans outweigh the cost of additional work.

## Minimizing correlated failures in distributed systems - Joe Mageramov

Use random jitter across many time based operations to reduce the chance of correlated failures. It's a good idea to use a value such as the server IP address as a seed to help with debugging.

## Making retries safe with idempotent APIs - Malcolm Featonby

For particular services it is worth publishing an idempotency contract. The API contains a `clientToken` parameter, which identifies client requests. The service caches requests and their results and returns cached results in the case that a duplicate `clientToken` is received. Furthermore, the parameters of the requests are stored too, and if the `clientToken` matches but the parameters are different, then the service returns an error. In this way it is assumed that the client made an error if sending two differently parameterized requests with the same token. Amazon found it reasonable to expire cached results after a certain time.

## Leader election in distributed systems - Marc Brooker

Use a distributed lock service to elect a leader. The devil is in the details of course...

## Instrumenting distributed systems for operational visibility - David Yanacek

Verbosely log systems to help you and your clients to debug and anticipate problems. In particular

- Prefer to pass around trace id's to help connect log statements between services.
- Pass around metric aggregation objects to be able to log a comprehensible set of metrics at the end of a processing pipeline.
- Test logging at max throughput and consider logging to different disk partitions, logging to a ramdisk or temporary file system, or writing compressed logs. If writing compressed logs be sure to use a compression algorithm that can handle truncation.
- Rotate logs more frequently in order to spread out the work done to transfer or compress the data and avoid spikes in resource utilization, even if this results in slightly more work overall.
- Use opt-in for logging sensitive data, this prevents the scenario where you accidentally add sensitive data to a log, if using opt-out.

#### [Amazon Builders' Library](https://aws.amazon.com/builders-library)

#### [Shuffle Sharding Implementation](https://github.com/awslabs/route53-infima)
